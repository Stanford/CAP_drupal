<?php
/**
 * @file
 * Code for the Stanford CAP API feature.
 */

include_once 'stanford_cap_api_profiles.features.inc';
include_once 'stanford_cap_api_profiles.admin.inc';
define('CAP_FIELDS_PREFIX', 'cap_');
define('CAP_FIELDS_IMPORT_ALL', 'import_all');
define('CAP_FIELDS_IMPORT_LIST', 'import_list');
define('CAP_PROFILES_PER_REQUEST', 10);

/**
 * Implements hook_menu().
 */
function stanford_cap_api_profiles_menu() {
  $items = array();

  if (variable_get('stanford_cap_api_profiles_schema_synchronized', FALSE)) {
    $items['admin/config/cap/config/import'] = array(
      'title' => 'Profile import',
      'description' => 'Provides administrators ability to import CAP profiles.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('stanford_cap_api_profiles_import_form'),
      'access arguments' => array('administer cap api'),
      'weight' => -4,
      'file' => 'stanford_cap_api_profiles.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );

    $items['admin/config/cap/config/import/result'] = array(
      'title' => 'Profile import',
      'description' => 'Provides administrators ability to import CAP profiles.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('stanford_cap_api_profiles_import_result_form'),
      'access arguments' => array('administer cap api'),
      'file' => 'stanford_cap_api_profiles.admin.inc',
      'type' => MENU_CALLBACK,
    );

    $items['admin/config/cap/config/group'] = array(
      'title' => 'Group import',
      'description' => 'Provides administrators ability to synchronize groups of CAP profiles.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('stanford_cap_api_profiles_group_sync_form'),
      'access arguments' => array('administer cap api'),
      'weight' => -5,
      'file' => 'stanford_cap_api_profiles.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );

    $items['admin/config/cap/config/group/%/delete'] = array(
      'title' => 'Drop group from synchronization',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('stanford_cap_api_profiles_group_sync_drop_form', 5),
      'access arguments' => array('administer cap api'),
      'type' => MENU_CALLBACK,
      'file' => 'stanford_cap_api_profiles.admin.inc',
    );

    $items['admin/config/cap/config/group/%/sync'] = array(
      'title' => 'Synchronize group',
      'page callback' => 'stanford_cap_api_profiles_group_sync_now',
      'page arguments' => array(5),
      'access arguments' => array('administer cap api'),
      'type' => MENU_CALLBACK,
      'file' => 'stanford_cap_api_profiles.admin.inc',
    );

    $items['stanford-cap-api-user-autocomplete'] = array(
      'title' => 'Autocomplete for CAP profile names',
      'page callback' => 'stanford_cap_api_profiles_user_autocomplete',
      'access arguments' => array('administer cap api'),
      'type' => MENU_CALLBACK,
      'file' => 'stanford_cap_api_profiles.admin.inc',
    );

    $items['stanford-cap-api-org-autocomplete'] = array(
      'title' => 'Autocomplete for CAP organization names',
      'page callback' => 'stanford_cap_api_profiles_taxonomy_autocomplete',
      'access arguments' => array('administer cap api'),
      'type' => MENU_CALLBACK,
      'file' => 'stanford_cap_api_profiles.admin.inc',
    );
  }

  return $items;
}

/**
 * Implements hook_permission().
 */
function stanford_cap_api_profiles_permission() {
  $permissions = array(
    'administer cap api' => array(
      'title' => t('Administer CAP API'),
    ),
  );

  return $permissions;
}

/**
 * Implements hook_menu_alter().
 */
function stanford_cap_api_profiles_menu_alter(&$items) {
  $items['node/%node/edit']['access callback'] = 'stanford_cap_api_profiles_node_access';
  $items['admin/structure/types/manage/%node_type/fields']['access callback'] = 'stanford_cap_api_profiles_user_access';
  $items['admin/structure/types/manage/%node_type/fields']['access arguments'][] = 4;
}

/**
 * Access check callback.
 */
function stanford_cap_api_profiles_node_access($op, $node) {
  $access = node_access($op, $node);
  if ($access && $node->type == 'cap_stanford_profile') {
    if (!variable_get('stanford_cap_api_profile_allow_edit', FALSE)) {
      $access = FALSE;
    }
  }

  return $access;
}

/**
 * Access check callback.
 */
function stanford_cap_api_profiles_user_access($permission, $node_type) {
  $access = user_access($permission);
  if ($access && $node_type->type == 'cap_stanford_profile') {
    if (!variable_get('stanford_cap_api_profile_custom_fields', FALSE)) {
      $access = FALSE;
    }
  }

  return $access;
}

/**
 * Implements hook_cron().
 */
function stanford_cap_api_profiles_cron() {

  // Allowed configuration options.
  $allowed = array('daily', 'nightly');
  $type = variable_get('stanford_cap_api_profile_update', 'donotsync!');
  if (!in_array($type, $allowed)) {
    return;
  }

  $tz = variable_get('date_default_timezone');
  $date = new DateObject('now', $tz);
  $time_of_day = $date->format('H:i');
  $min = variable_get('stanford_cap_api_profile_update_daily_start', '01:00');
  $max = variable_get('stanford_cap_api_profile_update_daily_end', '05:00');

  // make sure min and max are 24hrs
  if (stripos($min, "am") || stripos($min, 'pm')) {
    $min = date("H:i", strtotime($min));
  }

  if (stripos($max, "am") || stripos($max, 'pm')) {
    $max = date("H:i", strtotime($max));
  }

  if ($time_of_day >= $min && $time_of_day <= $max) {
    _stanford_cap_api_profiles_execute_cron();
  }

}

/**
 * The functions to run after cron conditions are met.
 * @return [type] [description]
 */
function _stanford_cap_api_profiles_execute_cron() {
  watchdog('stanford_cap_api_profiles', 'Cron sync profiles ran.', NULL, WATCHDOG_INFO);
  stanford_cap_api_profiles_synchronize_schema();
  stanford_cap_api_profiles_update_profiles();
  stanford_cap_api_profiles_sync_group_cron();
  variable_set('stanford_cap_api_profiles_cron_last_run', REQUEST_TIME);
}

/**
 * Import CAP profile.
 *
 * @param int $profile_id
 *   Profile ID.
 */
function stanford_cap_api_profiles_profile_import($profile_id) {
  try {
    $etag = stanford_cap_api_profiles_get_profile_etag($profile_id);
    $stored_metadata = stanford_cap_api_profiles_get_stored_profile_data($profile_id);
    if (empty($etag) && !empty($stored_metadata['etag'])) {
      // Profile is synced, but deleted from CAP.
      $action = variable_get('stanford_cap_api_profiles_orphaned_action', 'unpublish');
      switch ($action) {
        case 'unpublish':
          $nid = db_select('cap_api_profiles', 'p')
            ->condition('profile_id', $profile_id)
            ->fields('p', array('nid'))
            ->execute()
            ->fetchField();
          $node = node_load($nid);
          $node->status = NODE_NOT_PUBLISHED;
          node_save($node);
          db_delete('cap_api_profiles')
            ->condition('nid', $nid)
            ->execute();
          break;

        case 'remove':
          $nid = db_select('cap_api_profiles', 'p')
            ->condition('profile_id', $profile_id)
            ->fields('p', array('nid'))
            ->execute()
            ->fetchField();
          node_delete($nid);
          break;
      }
    }
    elseif (!empty($stored_metadata['etag']) && empty($stored_metadata['sync'])) {
      // Do nothing, we have synced flag off.
    }
    elseif (empty($stored_metadata['etag']) || $etag != $stored_metadata['etag']) {
      // Profile not stored or updated.
      $profile = stanford_cap_api_profiles_get_profile($profile_id);
      if ($profile) {
        if (!variable_get('stanford_cap_api_profiles_schema_synchronized', FALSE)) {
          stanford_cap_api_profiles_synchronize_schema();
        }
        stanford_cap_api_profiles_synchronize_data($profile);
      }
    }

  } catch (Exception $e) {
    $callstack = $e->getTrace();
    $menu_handler_call_step = $callstack[count($callstack) - 2];
    if ($menu_handler_call_step['args'][0] == 'system_batch_page') {
      watchdog('stanford_cap_api_profiles', 'Exception while profile @profile_id import. '.$e->getMessage(), array('@profile_id' => $profile['profileId']), WATCHDOG_ERROR);
    }
    else {
      throw new Exception('Exception while profile '. $profile['profileId'] .' import. '.$e->getMessage(), NULL, $e);
    }
  }
}

/**
 * Loads profile from CAP network.
 *
 * @param string $profile_id
 *   Profile ID.
 *
 * @return array|FALSE
 *   Profile or FALSE.
 */
function stanford_cap_api_profiles_get_profile($profile_id) {
  $cache =& drupal_static(__FUNCTION__, array());
  if (empty($cache[$profile_id])) {
    $cache[$profile_id] = stanford_cap_api_request('/profiles/v1/' . $profile_id);
  }

  return $cache[$profile_id];
}

/**
 * Returns profile type.
 *
 * @param array $profile
 *   CAP API profile.
 *
 * @return string
 *   Type.
 */
function stanford_cap_api_profiles_get_profile_type($profile) {
  foreach ($profile['affiliations'] as $affiliation => $enabled) {
    if ($affiliation == 'capFaculty' && $enabled) {
      $type = 'faculty';
      break;
    }
  }

  return $type;
}

/**
 * Finished callback for profiles import page.
 */
function stanford_cap_api_profiles_import_result_finished() {
  drupal_set_message(t('Profiles imported!'));
  unset($_SESSION['search_params']);
  unset($_SESSION['search_response']);
  drupal_goto('admin/config/cap/config/import');
}

/**
 * Synchronize CAP network profile data with Drupal node.
 *
 * @param array $profile
 *   CAP network profile.
 */
function stanford_cap_api_profiles_synchronize_data($profile) {
  $nid = db_select('cap_api_profiles', 'cap')
    ->fields('cap', array('nid'))
    ->condition('profile_id', $profile['profileId'])
    ->execute()
    ->fetchField();
  $node = $nid ? node_load($nid) : FALSE;
  if ($node) {
    stanford_cap_api_profiles_node_fields_update($node, $profile);
  }
  else {
    // Importing.
    $node = new stdClass();
    $node->title = $profile['displayName'];
    $node->uid = 0;
    $node->status = 1;
    $node->type = 'cap_stanford_profile';
    $node->created = REQUEST_TIME;
    $node->changed = REQUEST_TIME;
    $node->is_new = TRUE;
    $node->language = LANGUAGE_NONE;
    node_save($node);
    $node = node_load($node->nid, NULL, TRUE);
    stanford_cap_api_profiles_node_fields_import($node, $profile);
  }
  // Saving profile<->node association.
  $record = array(
    'profile_id' => $profile['profileId'],
    'nid' => $node->nid,
    'etag' => $profile['meta']['etag'],
  );
  db_merge('cap_api_profiles')
    ->key(array('profile_id' => $profile['profileId']))
    ->fields($record)
    ->execute();
}

/**
 * Save profile fields to node.
 *
 * @param object $node
 *   Nodes objects, to which fields will be attached.
 * @param array $profile
 *   Profile fetched from CAP API.
 */
function stanford_cap_api_profiles_node_fields_import($node, $profile) {
  $nw = entity_metadata_wrapper('node', $node);
  try {
    foreach ($profile as $field_name => $field_data) {
      _stanford_cap_api_profiles_save_field($node, $nw, $field_name, $field_data);
    }
    _stanford_cap_api_profiles_fill_basic_fields($nw, $profile);
    $nw->save();
  } catch (EntityMetadataWrapperException $e) {
    throw new Exception(t('EntityMetadataWrapper Exception while syncing profile @profile_id to @id @entity_type. Exception message: '.$e->getMessage(),
      array('@profile_id' => $profile['profileId'], '@id' => $nw->getIdentifier(), '@entity_type' => $nw->type())));
  }

  _stanford_cap_api_profiles_store_node_field_hashes($profile['profileId'], $node, $nw);
}

/**
 * Stores profile node field hashes in DB.
 *
 * We storing serialized raw field values for most fields and
 * entity/revision IDs  array for field colletions because raw()
 * metadata wrapper method returns full field collection object.
 * Doesn't use any hashing because we need to deal not only with strings.
 *
 * @param int $profile_id
 * @param object $node
 * @param object $nw
 */
function _stanford_cap_api_profiles_store_node_field_hashes($profile_id, $node, $nw) {
  $bundled_fields = array(
    'cap_profile_link',
    'cap_sync_date',
    'cap_profile_image',
  );
  // Storing profile field hashes to check if data was changed later.
  $props_info = $nw->getPropertyInfo();
  $fields = field_info_instances('node', 'cap_stanford_profile');
  foreach ($fields as $field_name => $field_instance) {
    if (!in_array($field_name, $bundled_fields)) {
      // Using raw values for all fields, but field_collections, they
      // return full field_collection object as raw.
      if ($props_info[$field_name]['type'] == 'field_collection_item') {
        $hash = $node->{$field_name};
      }
      else {
        $hash = $nw->{$field_name}->raw();
      }
      $key = array(
        'profile_id' => $profile_id,
        'field_name' => $field_name,
      );
      $record = $key + array(
        'hash' => serialize($hash),
      );
      db_merge('cap_api_field_hashes')->key($key)->fields($record)->execute();
    }
  }
}

/**
 * Set basic profile fields value.
 *
 * @param object $nw
 *   Node wrapper object.
 * @param array $profile
 *   CAP profile.
 */
function _stanford_cap_api_profiles_fill_basic_fields(EntityDrupalWrapper &$nw, $profile) {
  $nw->cap_profile_link->set(array('url' => _stanford_cap_api_profiles_get_cap_profile_url($profile)));
  $nw->cap_sync_date->set(REQUEST_TIME);
  // Organization relation handling.
  $org_tid = _stanford_cap_api_profiles_get_orantization_tid($nw, 'short');
  if (!$org_tid) {
    // Lets try long title;
    $org_tid = _stanford_cap_api_profiles_get_orantization_tid($nw, 'long');
  }
  if ($org_tid) {
    $nw->field_cap_profile_organization = $org_tid;
  }
  // Profile image handling.
  if (!empty($profile['profilePhotos'])) {
    $image_type = 'bigger';
    $fid = _stanford_cap_api_profiles_save_image_file($image_type, $profile['profilePhotos'][$image_type]);
    if (isset($fid)) {
      $nw->cap_profile_image = array('fid' => $fid);
    }
  }
}

/**
 * Update profile fields in node.
 *
 * @param object $node
 *   Nodes objects, to which fields will be attached.
 * @param array $profile
 *   Profile fetched from CAP API.
 */
function stanford_cap_api_profiles_node_fields_update($node, $profile) {
  $nw = entity_metadata_wrapper('node', $node);
  $props_info = $nw->getPropertyInfo();
  $profile_id = $profile['profileId'];
  foreach ($profile as $field_name => $field_data) {
    $drupal_field_name = _stanford_cap_api_profiles_get_field_name($field_name, '', TRUE);
    if (isset($props_info[$drupal_field_name])) {
      if (isset($node->{$drupal_field_name})) {
        $stored_hash = db_select('cap_api_field_hashes', 'hashes')
          ->condition('profile_id', $profile_id)
          ->condition('field_name', $drupal_field_name)
          ->fields('hashes', array('hash'))
          ->execute()
          ->fetchField();
        // Using raw values for all fields, but field_collections, they
        // return full field_collection object as raw.
        if ($props_info[$drupal_field_name]['type'] == 'field_collection_item') {
          $hash = serialize($node->{$drupal_field_name});
        }
        else {
          $hash = serialize($nw->{$drupal_field_name}->raw());
        }
        if ($stored_hash == $hash) {
          // Field data didn't changed till import, this means we can update it.
          $nw->{$drupal_field_name}->set(NULL);
          _stanford_cap_api_profiles_save_field($node, $nw, $field_name, $field_data);
        }
      }
      else {
        // We know about this field, but it had no data before.
        _stanford_cap_api_profiles_save_field($node, $nw, $field_name, $field_data);
      }
    }
  }

  try {
    _stanford_cap_api_profiles_fill_basic_fields($nw, $profile);
    $nw->save();
  } catch (EntityMetadataWrapperException $e) {
    throw new Exception(t('EntityMetadataWrapper Exception while syncing profile @profile_id to @id @entity_type. Exception message: '.$e->getMessage(),
      array('@profile_id' => $profile['profileId'], '@id' => $nw->getIdentifier(), '@entity_type' => $nw->type())));



  }

  _stanford_cap_api_profiles_store_node_field_hashes($profile_id, $node, $nw);
}

/**
 * Import multiple CAP profiles.
 *
 * @param array $profile_ids
 *   Array of profile ID's.
 */
function stanford_cap_api_profiles_profile_import_multiple($profile_ids) {
  foreach ($profile_ids as $profile_id) {
    stanford_cap_api_profiles_profile_import($profile_id);
  }
}

/**
 * Updates already imported profiles.
 */
function stanford_cap_api_profiles_update_profiles() {
  $profile_ids = db_select('cap_api_profiles', 'profiles')
    ->fields('profiles', array('profile_id'))
    ->execute()
    ->fetchCol();
  stanford_cap_api_profiles_profile_import_multiple($profile_ids);
}

/**
 * Returns etag for specified profile from CAP.
 *
 * Etag is checksum used to determine if profile was changed in CAP.
 *
 * @param string $profile_id
 *   CAP profile ID.
 *
 * @return string|FALSE
 *   CAP profile etag or FALSE.
 */
function stanford_cap_api_profiles_get_profile_etag($profile_id) {
  $etag = FALSE;
  if (is_numeric($profile_id)) {
    $profile = stanford_cap_api_profiles_get_profile($profile_id);
    if ($profile && isset($profile['meta']['etag'])) {
      $etag = $profile['meta']['etag'];
    }
  }

  return $etag;
}

/**
 * Returns metadata for stored specified profile.
 *
 * @param string $profile_id
 *   CAP profile ID.
 *
 * @return array|FALSE
 *   CAP profile metadata or FALSE.
 */
function stanford_cap_api_profiles_get_stored_profile_data($profile_id) {
  $data = FALSE;
  if (is_numeric($profile_id)) {
    $data = db_select('cap_api_profiles', 'cap')
      ->fields('cap')
      ->condition('profile_id', $profile_id)
      ->execute()->fetchAssoc();
  }

  return $data;
}

/**
 * Synchronize profiles of specified organization.
 *
 * @param string $org_code
 *   CAP organization code.
 * @param array $operations
 *   Array to gather operations for batch processing, also used as indicator
 *   for batch mode.
 *
 * @return int
 *   Count of synced profiles.
 *
 * @see http://www.stanford.edu/dept/pres-provost/budget/org/orgchart/
 */
function stanford_cap_api_profiles_sync_org_members($org_code, &$operations = array(), $sync_children = 0) {
  $params = array('orgCodes' => $org_code);
  if (!empty($sync_children)) {
    $params['includeChildren'] = TRUE;
  }

  return _stanford_cap_api_sync_members($org_code, $operations, $params);
}

/**
 * Helper to sync group members.
 *
 * @param string $group
 *   Machine readable group name.
 * @param array $operations
 *   Array of operations to use in batch set definition.
 * @param array $params
 *   Array of params for stanford_cap_api_request().
 *
 * @return int
 *   Number of synced profiles.
 *
 * @see stanford_cap_api_request()
 */
function _stanford_cap_api_sync_members($group, &$operations, $params) {
  $count = 0;
  // This request used to get count of profiles of this group.
  $data = stanford_cap_api_request('/profiles/v1', $params);
  if ($data && $data['totalCount'] > 0) {
    $params['ps'] = CAP_PROFILES_PER_REQUEST;
    $requests_count = $data['totalPages'];
    for ($i = 0; $i < $requests_count; $i++) {
      $params['p'] = $i + 1;
      $data = stanford_cap_api_request('/profiles/v1', $params);
      if (!empty($data['values']) && is_array($data['values'])) {
        // Summing up received profiles.
        $count += count($data['values']);
        foreach ($data['values'] as $profile) {
          if (!empty($operations)) {
            $operations[] = array(
              'stanford_cap_api_profiles_profile_import',
              array($profile['profileId']),
            );
          }
          else {
            stanford_cap_api_profiles_profile_import($profile['profileId']);
          }
        }
      }
      else {
        watchdog(
          'stanford_cap_api_profiles',
          'There was an issue while retrieving data from CAP service for "@group" group.',
          array('@group' => $group)
        );
      }
    }

  }

  return $count;
}

/**
 * Synchronize profiles of specified workgroup.
 *
 * @param string $workgroup_id
 *   CAP workgroup ID.
 * @param array $operations
 *   Array to gather operations for batch processing, also used as indicator
 *  for batch mode.
 *
 * @return int
 *   Count of synced profiles.
 */
function stanford_cap_api_profiles_sync_workgroup_members($workgroup_id, &$operations = array()) {
  $params = array('privGroups' => $workgroup_id);

  return _stanford_cap_api_sync_members($workgroup_id, $operations, $params);
}

/**
 * Save CAP group for synchronization.
 *
 * @param string $type
 *   Type of group.
 * @param string $name
 *   Machine readable group name.
 * @param int $count
 *   Quantity of profiles associated with this group.
 * @param int $lastsynced
 *   Last synchronization timestamp.
 * @param int $sync_children
 *   Flag indicating to import all the profiles in organization and any of its children.
 */
function stanford_cap_api_profiles_sync_group_save($type, $name, $count = 0, $lastsynced = NULL, $sync_children = 0) {
  $record = array('name' => $name, 'type' => $type);
  if (isset($count)) {
    $record['count'] = $count;
  }
  if (isset($lastsynced)) {
    $record['lastsynced'] = $lastsynced;
  }
  if (isset($sync_children)) {
    $record['sync_children'] = $sync_children;
  }
  db_merge('cap_api_sync_groups')
    ->key(array('name' => $name, 'type' => $type))
    ->fields($record)
    ->execute();
}

/**
 * Synchronize profiles of group.
 *
 * @param string $type
 *   Type of group.
 * @param string $name
 *   Group name.
 */
function stanford_cap_api_profiles_sync_group_sync($type, $name, $sync_children = 0) {
  switch ($type) {
    case 'organization':
      $count = stanford_cap_api_profiles_sync_org_members($name, $ops = array(), $sync_children);
      stanford_cap_api_profiles_sync_group_save($type, $name, $count, REQUEST_TIME, $sync_children);
      break;

    case 'workgroup':
      $count = stanford_cap_api_profiles_sync_workgroup_members($name);
      stanford_cap_api_profiles_sync_group_save($type, $name, $count, REQUEST_TIME);
      break;
  }
}

/**
 * Drop profiles group from synchronization.
 *
 * @param int $id
 *   Internal group ID.
 */
function stanford_cap_api_profiles_sync_group_drop($id) {
  db_delete('cap_api_sync_groups')->condition('id', $id)->execute();
}

/**
 * Callback for cron groups synchronization.
 */
function stanford_cap_api_profiles_sync_group_cron() {
  $groups = db_select('cap_api_sync_groups', 'groups')
    ->fields('groups')
    ->execute()
    ->fetchAll();
  foreach ($groups as $group) {
    stanford_cap_api_profiles_sync_group_sync($group->type, $group->name, $group->sync_children);
  }
}

/**
 * Implements hook_node_delete().
 */
function stanford_cap_api_profiles_node_delete($node) {
  db_delete('cap_api_profiles')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_node_view().
 */
function stanford_cap_api_profiles_node_view($node, $view_mode) {
  $update_strategy = variable_get('stanford_cap_api_profile_update', 'nightly');
  if ($node->type == 'cap_stanford_profile' && $view_mode == 'full' && $update_strategy == 'viewing') {
    $profile_id = db_select('cap_api_profiles', 'p')
      ->condition('nid', $node->nid)
      ->fields('p', array('profile_id'))
      ->execute()
      ->fetchField();
    if ($profile_id) {
      stanford_cap_api_profiles_profile_import($profile_id);
    }
  }
}

/**
 * Implements hook_action_info().
 */
function stanford_cap_api_profiles_action_info() {
  return array(
    'stanford_cap_api_profiles_profile_stop_sync_action' => array(
      'type' => 'node',
      'label' => t('Stop profile synchronization'),
      'configurable' => FALSE,
      'triggers' => array(),
    ),
  );
}

/**
 * Stop profile syncing action.
 */
function stanford_cap_api_profiles_profile_stop_sync_action($entity) {
  if ($entity->type == 'cap_stanford_profile') {
    $count = db_update('cap_api_profiles')
      ->condition('nid', $entity->nid)
      ->fields(array('sync' => 0))
      ->execute();
    if ($count == 1) {
      watchdog(
        'stanford_cap_api_profiles',
        'Profile with ID %ID will not be synced anymore.',
        array('%ID' => $entity->cap_profileid[LANGUAGE_NONE][0]['value'])
      );
    }
  }
}

/**
 * Synchronize profile structure based on profile schema.
 *
 * Could be called in 2 modes: 1) batch mode - when field creation will be
 * queued in batch operations; 2) normal mode - field will be created during
 * function execution, good for cron and drush runs.
 *
 * @param bool $batch
 *   Indicates that batch mode should be used.
 */
function stanford_cap_api_profiles_synchronize_schema($batch = FALSE) {
  if ($batch) {
    variable_set('stanford_cap_api_profiles_sync_schema_batch', REQUEST_TIME);
    $operations = array();
  }
  $schema = stanford_cap_api_profiles_get_profile_schema();
  $stored_schema_hash = variable_get('stanford_cap_api_profiles_schema_hash');
  if (!variable_get('stanford_cap_api_profiles_schema_synchronized') || $stored_schema_hash != _stanford_cap_api_profiles_schema_hash($schema)) {
    // Basic check that we have an expected schema.
    if (is_array($schema) && $schema['type'] == 'object' && !empty($schema['properties'])) {
      foreach ($schema['properties'] as $f_name => $f_schema) {
        if ($batch) {
          _stanford_cap_api_profiles_synchronize_schema_subfields($f_name, $f_schema, '', '', $operations);
        }
        else {
          _stanford_cap_api_profiles_synchronize_schema_subfields($f_name, $f_schema);
        }
      }
      if ($batch) {
        $operations[] = array(
          'variable_set',
          array('stanford_cap_api_profiles_schema_synchronized', TRUE),
        );
        $batch = array(
          'title' => t('Importing CAP data'),
          'operations' => $operations,
          'finished' => '_stanford_cap_api_profiles_sync_schema_batch_finished',
          'progress_message' => t('Importing the structure of CAP profiles: @current of @total.'),
        );
        batch_set($batch);
      }
      else {
        variable_set('stanford_cap_api_profiles_schema_synchronized', TRUE);
      }
      variable_set('stanford_cap_api_profiles_schema_hash', _stanford_cap_api_profiles_schema_hash($schema));
    }
  }
}

/**
 * Get schema for profile type.
 *
 * @return array
 *   Profile type schema.
 */
function stanford_cap_api_profiles_get_profile_schema() {
  return stanford_cap_api_request('/cap/v1/schemas/profile');
}

/**
 * Implements hook_theme().
 */
function stanford_cap_api_profiles_theme() {
  return array(
    'stanford_cap_api_profiles_field_tree' => array(
      'render element' => 'schema_tree',
      'file' => 'stanford_cap_api_profiles.theme.inc',
    ),
  );
}

/**
 * Writes created field name to DB.
 *
 * @param string $field_name
 *   Field name to log.
 */
function _stanford_cap_api_profiles_log_field($field_name) {
  $record = array('field_name' => $field_name);
  drupal_write_record('cap_api_fields', $record);
  watchdog('stanford_cap_api_profiles', 'Field @field was created by stanford_cap_api_profiles module.', array('@field' => $field_name));
}

/**
 * Generates CAP network profile URL.
 *
 * @todo Remove this when appropriate field would be available.
 *
 * @param array $profile
 *   CAP network profile.
 *
 * @return string
 *   CAP network profile URL.
 */
function _stanford_cap_api_profiles_get_cap_profile_url($profile) {
  $href = '';
  if (isset($profile['meta']) && !empty($profile['meta']['links'])) {
    foreach ($profile['meta']['links'] as $link) {
      // Searching for public link.
      if ($link['rel'] == 'https://cap.stanford.edu/rel/public') {
        $href = $link['href'];
        break;
      }
    }
  }
  if (empty($href)) {
    // Fallback.
    // Public profile link not found, lets generate it.
    $href = variable_get('stanford_cap_uri', 'https://profiles-beta.stanford.edu/');
    if (!empty($profile['alias'])) {
      $href .= $profile['alias'];
    }
  }

  return $href;
}

/**
 * Generate Drupal compliant field name or retrieve it from DB.
 *
 * @param string $field_name
 *   CAP profile field name.
 * @param string $parent
 *   Full parent field path(e.g "shortTitle.label" for 'label' field attached
 * to 'shortTitle').
 * @param bool $from_db
 *   Indicates whether Drupal field name should be generated or fetched from DB.
 *
 * @return string
 *   Drupal field name.
 */
function _stanford_cap_api_profiles_get_field_name($field_name, $parent = '', $from_db = FALSE) {
  $drupal_field_name = drupal_substr(CAP_FIELDS_PREFIX . drupal_strtolower($field_name), 0, 29);
  $args = array(':field_name' => $drupal_field_name . '%');
  $query = 'SELECT COUNT(field_name) AS similar_fields FROM {cap_api_fields_map} WHERE field_name LIKE :field_name';
  $similar_fields = (int) db_query($query, $args)->fetchField();
  if ($similar_fields) {
    if ($from_db) {
      $field_path = empty($parent) ? $field_name : $parent . '.' . $field_name;
      $drupal_field_name = db_select('cap_api_fields_map', 'map')
        ->fields('map', array('field_name'))
        ->condition('field_path', $field_path)
        ->execute()
        ->fetchField();
    }
    else {
      $drupal_field_name .= '_' . ++$similar_fields;
    }
  }

  return $drupal_field_name;
}

/**
 * Helper to get stored field info by field path.
 *
 * @param string $field_path
 *   Field path from layout schema.
 *
 * @return array
 *   Stored field info.
 */
function _stanford_cap_api_profiles_get_field_info_by_path($field_path) {
  return db_select('cap_api_fields_map', 'm')
    ->fields('m')
    ->condition('field_path', $field_path)
    ->execute()
    ->fetchAssoc();
}

/**
 * Save CAP profile field value.
 *
 * @param object $entity
 *   Host entity of field.
 * @param object $wrapper
 *   Entity wrapper.
 * @param string $field_name
 *   CAP profile field name.
 * @param array $field_data
 *   CAP profile field data.
 * @param string $parent_field
 *   Parent field name.
 */
function _stanford_cap_api_profiles_save_field(&$entity, &$wrapper, $field_name, $field_data, $parent_field = '') {

  $drupal_field_name = _stanford_cap_api_profiles_get_field_name($field_name, $parent_field, TRUE);
  $props_info = $wrapper->getPropertyInfo();
  if (isset($props_info[$drupal_field_name])) {
    $field_info = field_info_field($drupal_field_name);
    switch ($field_info['type']) {
      case 'link':
        if (is_string($field_data)) {
          $wrapper->{$drupal_field_name}->set(array('url' => $field_data));
        }
        break;

      case 'date':
        if (is_string($field_data)) {
          $wrapper->{$drupal_field_name}->set(strtotime($field_data));
        }
        elseif (!empty($field_data['value'])) {
          $wrapper->{$drupal_field_name}->set(strtotime($field_data['value']));
        }
        break;

      case 'text':
        if (is_string($field_data)) {
          $value = _stanford_cap_api_profiles_get_field_value_text($field_name, $field_data, $field_info);
          $wrapper->{$drupal_field_name}->set($value);
        }
        elseif (is_array($field_data) && !empty($field_data['html']) && !empty($field_data['text'])) {
          $field_data = $field_data['text'];
          $value = _stanford_cap_api_profiles_get_field_value_text($field_name, $field_data, $field_info);
          $wrapper->{$drupal_field_name}->set($value);
        }
        elseif (is_array($field_data) && $field_info['cardinality'] == '-1') {
          $values = array();
          foreach ($field_data as $f_data) {
            if (is_string($f_data)) {
              $values[] = _stanford_cap_api_profiles_get_field_value_text($field_name, $f_data, $field_info);
            }
            else {
              $error_msg = 'Field name: @field_name. Expecting string , got: @data.';
              $vars = array(
                '@field_name' => $field_name,
                '@data' => print_r($field_data, TRUE),
              );
              watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);
            }
          }
          $wrapper->{$drupal_field_name}->set($values);
        }
        break;

      case 'text_long':
        if (is_string($field_data)) {
          // Contains HTML?
          if ($props_info[$drupal_field_name]['type'] == 'text_formatted') {
            $wrapper->{$drupal_field_name}->set(array(
              'value' => $field_data,
              'format' => 'full_html_for_cap_profiles',
            ));
          }
          else {
            $wrapper->{$drupal_field_name}->set($field_data);
          }
        }
        elseif (is_array($field_data) && !empty($field_data['html']) && !empty($field_data['text']) && count($field_data) == 2) {
          $wrapper->{$drupal_field_name}->set(array(
            'value' => $field_data['html'],
            'format' => 'full_html_for_cap_profiles',
          ));
        }
        elseif (is_array($field_data) && $field_info['cardinality'] == '-1') {
          foreach ($field_data as $f_data) {
            if (!is_string($f_data)) {
              $error_msg = 'Field name: @field_name. Expecting string , got: @data.';
              $vars = array(
                '@field_name' => $field_name,
                '@data' => print_r($field_data, TRUE),
              );
              watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);
              break;
            }
          }
          $wrapper->{$drupal_field_name}->set($field_data);
        }
        else {
          $error_msg = 'Field name: @field_name. Expecting string , got: @data.';
          $vars = array(
            '@field_name' => $field_name,
            '@data' => print_r($field_data, TRUE),
          );
          watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);
          break;
        }
        break;

      case 'number_integer':
        if (is_numeric($field_data)) {
          $wrapper->{$drupal_field_name}->set($field_data);
        }
        break;

      case 'list_boolean':
        if (is_bool($field_data)) {
          $wrapper->{$drupal_field_name}->set($field_data);
        }
        break;

      case 'taxonomy_term_reference':
        if (is_string($field_data)) {
          $efq = new EntityFieldQuery();
          $efq->entityCondition('entity_type', 'taxonomy_term');
          $efq->fieldCondition('field_org_codes', 'value', $field_data);
          $results = $efq->execute();
          if (!empty($results['taxonomy_term']) && count($results['taxonomy_term']) == 1) {
            $org_term = array_shift($results['taxonomy_term']);
            $wrapper->{$drupal_field_name}->set($org_term);
          }
        }
        break;

      case 'field_collection':
        // This is multi-value field collection.
        if (is_array($field_data) && !empty($field_data) && array_key_exists(0, $field_data)) {
          foreach ($field_data as $fc_subfield_data) {
            _stanford_cap_api_profiles_save_field($entity, $wrapper, $field_name, $fc_subfield_data, $parent_field);
          }
        }
        else {
          if (is_array($field_data) && !empty($field_data)) {
            $fc_item = entity_create('field_collection_item', array('field_name' => $drupal_field_name));
            $entity_type = method_exists($entity, 'entityType') ? 'field_collection_item' : 'node';
            $fc_item->setHostEntity($entity_type, $entity);
            $fc_item->save(TRUE);
            $fc_wrapper = entity_metadata_wrapper('field_collection_item', $fc_item);
            foreach ($field_data as $fc_subfield => $fc_subfield_data) {
              $field_path = empty($parent_field) ? $field_name : $parent_field . '.' . $field_name;
              _stanford_cap_api_profiles_save_field($fc_item, $fc_wrapper, $fc_subfield, $fc_subfield_data, $field_path);
            }
            $fc_item->save(TRUE);
          }
        }
        break;

      case 'image':
        $ext = drupal_substr($field_data['contentType'], 6);
        // @todo Remove before release.
        $request_url = str_replace('cap-irt-dev', 'med', $field_data['url']);
        parse_str(parse_url($field_data['url'], PHP_URL_QUERY), $query);
        $profile_id = $query['facultyId'];

        $response = drupal_http_request($request_url);
        if (property_exists($response, 'error')) {
          $error_msg = 'Failed to fetch profile image of field %field_name for profile'
            . ' %profile_id . Error code is'
            . ' %code, error message is "%msg", request string was "%request".';
          $vars = array(
            '%code' => $response->code,
            '%msg' => $response->status_message,
            '%request' => $request_url,
            '%profile_id' => $profile_id,
            '%field_name' => $field_name,
          );
          watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);

          break;
        }
        $path = 'public://'
          . variable_get('cap_profile_photos', 'profile_photos')
          . '/profile_'
          . $profile_id . '_' . $field_data['type'] . '.' . $ext;
        $dir = drupal_dirname($path);
        if (!is_dir($dir) && !mkdir($dir)) {
          watchdog('stanford_cap_api_profiles', 'Failed to create directory %dir', array('%dir' => $dir), WATCHDOG_WARNING);

          break;
        }
        $file = file_save_data($response->data, $path, FILE_EXISTS_REPLACE);
        $wrapper->{$drupal_field_name}->set(array('fid' => $file->fid));

        break;
    }
  }
  elseif (variable_get('stanford_cap_api_import_profile_fields', CAP_FIELDS_IMPORT_ALL) == CAP_FIELDS_IMPORT_ALL) {
    // Let's log an issue when we want to import all fields, but this field
    // doesn't exists in Drupal.
    $message = 'Field "@field" was in profile, but were not defined in schema. Field data: @data';
    $vars = array(
      '@field' => $field_name,
      '@data' => print_r($field_data, TRUE),
    );
    watchdog('stanford_cap_api_profiles', $message, $vars, WATCHDOG_WARNING);
  }
}

/**
 * Get field value for text field.
 *
 * Truncate profile field length to maximum allowed for Drupal field.
 *
 * @param string $field_name
 *   Field name.
 * @param array $field_data
 *   Field data to process.
 * @param array $field_info
 *   Field info.
 *
 * @return string
 *   String to save as field value.
 */
function _stanford_cap_api_profiles_get_field_value_text($field_name, $field_data, $field_info) {
  $max_length = $field_info['columns']['value']['length'];
  $data_length = strlen($field_data);
  if ($data_length > $max_length) {
    $value = drupal_substr($field_data, 0, $max_length);
    $error_msg = 'Field "@field_name" data truncated. Expected data length "@length", got "@got".';
    $vars = array(
      '@field_name' => $field_name,
      '@length' => $max_length,
      '@got' => $data_length,
    );
    watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);
    _stanford_cap_api_profiles_log_longest_field_length($data_length);

    return $value;
  }
  else {
    return $field_data;
  }
}

/**
 * Generate field info based in field schema.
 *
 * @param string $drupal_field_name
 *   Generated Drupal field name.
 * @param string $field_name
 *   Field name form CAP API.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param string $field_path
 *   Field path for layout.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_generate_field_info($drupal_field_name, $field_name, $field_schema, $field_path) {
  $info = NULL;
  switch ($field_schema['type']) {
    case 'array':
      switch ($field_schema['items']['type']) {
        case 'string':
          $clob_fields = variable_get('stanford_cap_api_profiles_text_fields_list');
          if (in_array($field_path, $clob_fields)) {
            $info = _stanford_cap_api_profiles_gen_field_base_def_text_long($drupal_field_name, $field_schema, TRUE);
          }
          else {
            $info = _stanford_cap_api_profiles_gen_field_base_def_text($drupal_field_name, $field_schema, TRUE);
          }
          break;

        case 'object':
          $info = _stanford_cap_api_profiles_gen_field_base_def_field_collection($drupal_field_name, $field_schema, TRUE);
          break;

        default:
          $message = 'Unknown field items type "@type" in CAP profile schema: @schema';
          $vars = array(
            '@type' => $field_schema['items']['type'],
            '@schema' => print_r($field_schema, TRUE),
          );
          watchdog('stanford_cap_api_profiles', $message, $vars, WATCHDOG_WARNING);
      }
      break;

    case 'object':
      if (!empty($field_schema['properties'])) {
        $props = $field_schema['properties'];
        // This is not the real collection.
        // Simple string.
        if (variable_get('stanford_cap_api_import_fields_html', TRUE) && isset($props['html']) && isset($props['text']) && count($props) == 2) {
          $info = _stanford_cap_api_profiles_gen_field_base_def_text_long($drupal_field_name, $props['html']);
        }
        // Date field.
        elseif (isset($props['value']) && isset($props['html']) && isset($props['text']) && count($props) == 3) {
          $schema = $props['value'];
          if ($schema['type'] == 'string') {
            if (isset($schema['format']) && $schema['format'] == 'DATE_TIME') {
              $info = _stanford_cap_api_profiles_gen_field_base_def_date($drupal_field_name, $schema);
            }
          }
        }
        else {
          $info = _stanford_cap_api_profiles_gen_field_base_def_field_collection($drupal_field_name, $field_schema);
        }
      }
      break;

    case 'string':
      if ($field_name == 'orgCode') {
        $info = _stanford_cap_api_profiles_gen_field_base_def_taxonomy_term_reference($drupal_field_name, $field_schema);
      }
      else {
        $clob_fields = variable_get('stanford_cap_api_profiles_text_fields_list');
        if (in_array($field_path, $clob_fields)) {
          $info = _stanford_cap_api_profiles_gen_field_base_def_text_long($drupal_field_name, $field_schema);
        }
        else {
          $info = _stanford_cap_api_profiles_gen_field_base_def_text($drupal_field_name, $field_schema);
        }
      }
      break;

    case 'boolean':
      $info = _stanford_cap_api_profiles_gen_field_base_def_boolean($drupal_field_name, $field_schema);
      break;

    case 'integer':
      $info = _stanford_cap_api_profiles_gen_field_base_def_integer($drupal_field_name, $field_schema);
      break;

    default:
      $message = 'Unknown field type "@type" in CAP profile schema: @schema';
      $vars = array(
        '@type' => $field_schema['type'],
        '@schema' => print_r($field_schema, TRUE),
      );
      watchdog('stanford_cap_api_profiles', $message, $vars, WATCHDOG_WARNING);
  }

  return $info;
}

/**
 * Generate field instance info for specified field type.
 *
 * @param string $type
 *   Field type.
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_generate_instance_info($type, $drupal_field_name, $field_name, $schema, $parent_field = '') {
  $info = NULL;
  switch ($type) {
    case 'text':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_text($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'text_long':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_text_long($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'list_boolean':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_boolean($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'field_collection':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_field_collection($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'date':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_date($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'number_integer':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_integer($drupal_field_name, $field_name, $schema, $parent_field);
      break;

    case 'taxonomy_term_reference':
      $info = _stanford_cap_api_profiles_gen_field_instance_def_taxonomy_term_reference($drupal_field_name, $field_name, $schema, $parent_field);
      break;
  }

  return $info;
}

/**
 * Helper to synchronize CAP profile fields structure.
 *
 * @param string $f_name
 *   CAP API profile field name.
 * @param array $f_schema
 *   CAP API profile field schema.
 * @param string $drupal_parent_field
 *   Drupal parent field name.
 * @param string $parent_field
 *   Parent field name.
 * @param array $operations
 *   Array to gather operations for batch processing, also used as indicator
 *   for batch mode.
 */
function _stanford_cap_api_profiles_synchronize_schema_subfields($f_name, $f_schema, $drupal_parent_field = '', $parent_field = '', &$operations = NULL) {
  $field_weigth =& drupal_static(__FUNCTION__, 0);
  $field_path = empty($parent_field) ? $f_name : $parent_field . '.' . $f_name;
  $cap_field_info = _stanford_cap_api_profiles_get_field_info_by_path($field_path);
  if (empty($cap_field_info['field_name'])) {
    // Generate Drupal compliant field name.
    $drupal_field_name = _stanford_cap_api_profiles_get_field_name($f_name, $parent_field);
  }
  else {
    $drupal_field_name = $cap_field_info['field_name'];
  }
  $field_info = field_info_field($drupal_field_name);
  if (empty($field_info) && stanford_cap_api_profiles_synchronize_field($field_path)) {
    $field_info = _stanford_cap_api_profiles_generate_field_info($drupal_field_name, $f_name, $f_schema, $field_path);
    // Do we know about this field type?
    if (!empty($field_info)) {
      // We are in batch mode.
      if (isset($operations)) {
        $operations[] = array(
          'field_create_field',
          array($field_info),
        );
      }
      else {
        field_create_field($field_info);
      }
      // Logging field creation.
      _stanford_cap_api_profiles_log_field($drupal_field_name);
    }
  }
  $parent_entity = empty($parent_field) ? 'node' : 'field_collection_item';
  $parent_entity_bundle = empty($parent_field) ? 'cap_stanford_profile' : $drupal_parent_field;
  $field_instance = field_info_instance($parent_entity, $drupal_field_name, $parent_entity_bundle);
  if (empty($field_instance) && !empty($field_info)) {
    if (!isset($f_schema['weight'])) {
      $f_schema['weight'] = $field_weigth;
    }
    $field_instance = _stanford_cap_api_profiles_generate_instance_info($field_info['type'], $drupal_field_name, $f_name, $f_schema, $drupal_parent_field);
    if (!empty($field_instance)) {
      // We are in batch mode.
      if (isset($operations)) {
        $operations[] = array(
          'field_create_instance',
          array($field_instance),
        );
      }
      else {
        field_create_instance($field_instance);
      }
      _stanford_cap_api_profiles_store_field_map($drupal_field_name, $field_path, $parent_entity, $parent_entity_bundle);
    }
    else {
      $message = 'Failed to create field instance. Field info: @field_info';
      $vars = array(
        '@field_info' => print_r($field_info, TRUE),
      );
      watchdog('stanford_cap_api_profiles', $message, $vars, WATCHDOG_WARNING);
    }
  }
  $field_weigth++;
  if ($field_info['type'] == 'field_collection') {
    $subfield_weigth =& drupal_static(__FUNCTION__ . '_subfields', array());
    if (!isset($subfield_weigth[$drupal_field_name])) {
      $subfield_weigth[$drupal_field_name] = 0;
    }
    $subfields = array();
    // Multivalue field colletion.
    if ($f_schema['type'] == 'array' && $f_schema['items']['type'] == 'object') {
      $subfields = $f_schema['items']['properties'];
    }
    elseif ($f_schema['type'] == 'object' && !empty($f_schema['properties'])) {
      $subfields = $f_schema['properties'];
    }

    foreach ($subfields as $subfield => $schema) {
      if (!isset($schema['weight'])) {
        $schema['weight'] = $subfield_weigth[$drupal_field_name];
      }
      // We need this field to successfully apply profile layout.
      $field_path = empty($parent_field) ? $f_name : $parent_field . '.' . $f_name;
      _stanford_cap_api_profiles_synchronize_schema_subfields($subfield, $schema, $drupal_field_name, $field_path, $operations);
      $subfield_weigth[$drupal_field_name]++;
    }
  }
}

/**
 * Generate field info for text field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_text($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;
  if (!empty($field_schema['maxLength']) && is_numeric($field_schema['maxLength'])) {
    $max_length = (int) $field_schema['maxLength'];
  }
  else {
    $max_length = 512;
  }

  $info = array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'settings' => array(
      'max_length' => $max_length,
    ),
    'type' => 'text',
  );

  return $info;
}

/**
 * Generate field info for text_long field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_text_long($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  $info = array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'type' => 'text_long',
  );

  return $info;
}

/**
 * Generate field info for integer field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_integer($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  return array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'type' => 'number_integer',
  );
}

/**
 * Generate field info for field collection field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_field_collection($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  return array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'type' => 'field_collection',
  );
}

/**
 * Generate field info for boolean field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_boolean($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  return array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'type' => 'list_boolean',
    'settings' => array(
      'allowed_values' => array(
        0 => t('No'),
        1 => t('Yes'),
      ),
    ),
  );
}

/**
 * Generate field info for date field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_date($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  return array(
    'cardinality' => $cardinality,
    'settings' => array(
      'granularity' => array(
        'month' => 'month',
        'day' => 'day',
        'hour' => 'hour',
        'minute' => 'minute',
        'second' => 'second',
        'year' => 'year',
      ),
      'tz_handling' => 'site',
      'timezone_db' => 'UTC',
      'cache_enabled' => 0,
      'cache_count' => '4',
      'todate' => '',
    ),
    'field_name' => $field_name,
    'type' => 'date',
  );
}

/**
 * Generate field info for taxonomy_term_reference field.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param array $field_schema
 *   Field schema form CAP API.
 * @param bool $multivalue
 *   Indicates if the field is multivalue.
 *
 * @return array
 *   Array used in field_create_field().
 * @see field_create_field()
 */
function _stanford_cap_api_profiles_gen_field_base_def_taxonomy_term_reference($field_name, $field_schema, $multivalue = FALSE) {
  $cardinality = $multivalue ? -1 : 1;

  return array(
    'cardinality' => $cardinality,
    'field_name' => $field_name,
    'settings' => array(
      'allowed_values' => array(
        0 => array(
          'vocabulary' => CAP_ORGS_VOCAB,
          'parent' => 0,
        ),
      ),
    ),
    'type' => 'taxonomy_term_reference',
  );
}

/**
 * Generate field instance info for boolean field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_boolean($drupal_field_name, $field_name, $schema, $parent_field) {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'bundle' => $bundle,
    'description' => $description,
    'entity_type' => $entity_type,
    'field_name' => $drupal_field_name,
    'label' => $label,
    'widget' => array(
      'settings' => array(
        'display_label' => TRUE,
      ),
      'type' => 'options_onoff',
      'weight' => $weight,
    ),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for integer field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_integer($drupal_field_name, $field_name, $schema, $parent_field) {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'label' => $label,
    'display' => array(
      'default' => array(
        'label' => 'above',
        'type' => 'number_integer',
        'settings' => array(
          'thousand_separator' => '',
          'prefix_suffix' => 0,
          'decimal_separator' => '.',
          'scale' => 0,
        ),
        'module' => 'number',
      ),
    ),
    'description' => $description,
    'field_name' => $drupal_field_name,
    'entity_type' => $entity_type,
    'bundle' => $bundle,
    'widget' => array('weight' => $weight),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for text field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_text($drupal_field_name, $field_name, $schema, $parent_field = '') {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'bundle' => $bundle,
    'default_value' => NULL,
    'description' => $description,
    'entity_type' => $entity_type,
    'field_name' => $drupal_field_name,
    'label' => $label,
    'widget' => array('weight' => $weight),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for text_long field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_text_long($drupal_field_name, $field_name, $schema, $parent_field = '') {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'bundle' => $bundle,
    'description' => $description,
    'entity_type' => $entity_type,
    'field_name' => $drupal_field_name,
    'label' => $label,
    'settings' => array(
      'text_processing' => TRUE,
    ),
    'widget' => array('weight' => $weight),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for field collection field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_field_collection($drupal_field_name, $field_name, $schema, $parent_field = '') {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'bundle' => $bundle,
    'description' => $description,
    'entity_type' => $entity_type,
    'field_name' => $drupal_field_name,
    'label' => $label,
    'display' => array(
      'default' => array(
        'label' => 'above',
        'module' => 'field_collection',
        'settings' => array(
          'add' => '',
          'delete' => '',
          'description' => 1,
          'edit' => '',
          'view_mode' => 'full',
        ),
        'type' => 'field_collection_view',
        'weight' => 1,
      ),
    ),
    'widget' => array(
      'type' => 'field_collection_embed',
      'weight' => $weight,
    ),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for date field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_date($drupal_field_name, $field_name, $schema, $parent_field = '') {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'label' => $label,
    'widget' => array(
      'weight' => $weight,
      'type' => 'date_select',
      'module' => 'date',
      'active' => 1,
      'settings' => array(
        'input_format' => 'm/d/Y - H:i:s',
        'input_format_custom' => '',
        'year_range' => '-3:+3',
        'increment' => '15',
        'label_position' => 'above',
        'text_parts' => array(),
      ),
    ),
    'settings' => array(
      'default_value' => 'blank',
      'default_value_code' => '',
      'default_value2' => 'same',
      'default_value_code2' => '',
      'user_register_form' => FALSE,
    ),
    'description' => $description,
    'field_name' => $drupal_field_name,
    'entity_type' => $entity_type,
    'bundle' => $bundle,
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * Generate field instance info for taxonomy_term_reference field.
 *
 * @param string $drupal_field_name
 *   Drupal field name.
 * @param string $field_name
 *   CAP field name.
 * @param array $schema
 *   Field schema form CAP API.
 * @param string $parent_field
 *   Parent field name.
 *
 * @return array
 *   Array used in field_create_instance().
 * @see field_create_instance()
 */
function _stanford_cap_api_profiles_gen_field_instance_def_taxonomy_term_reference($drupal_field_name, $field_name, $schema, $parent_field = '') {
  $entity_type = empty($parent_field) ? 'node' : 'field_collection_item';
  $bundle = empty($parent_field) ? 'cap_stanford_profile' : $parent_field;
  $label = empty($schema['title']) ? $field_name : $schema['title'];
  $description = empty($schema['description']) ? '' : $schema['description'];
  $weight = isset($schema['weight']) ? $schema['weight'] : 0;
  $instance = array(
    'bundle' => $bundle,
    'description' => $description,
    'entity_type' => $entity_type,
    'field_name' => $drupal_field_name,
    'label' => $label,
    'widget' => array(
      'module' => 'taxonomy',
      'settings' => array(
        'autocomplete_path' => 'taxonomy/autocomplete',
        'size' => 60,
      ),
      'type' => 'taxonomy_autocomplete',
      'weight' => $weight,
    ),
  );

  if (!empty($schema['metadata'])) {
    $instance['display']['default']['type'] = 'hidden';
  }

  return $instance;
}

/**
 * We might want to know largest field size.
 */
function _stanford_cap_api_profiles_log_longest_field_length($length) {
  $stored_length = variable_get('stanford_cap_api_profiles_longest_field_length');
  if ($stored_length < $length) {
    variable_set('stanford_cap_api_profiles_longest_field_length', $length);
  }
}

/**
 * Logs field instance mapping to profile fields.
 *
 * Mapping done in the way it's done in CAP API layout schema.
 *
 * @param string $field_name
 *   Drupal field name.
 * @param string $field_path
 *   Field path for layout.
 * @param string $entity_type
 *   Entity type.
 * @param string $bundle
 *   Entity bundle.
 */
function _stanford_cap_api_profiles_store_field_map($field_name, $field_path, $entity_type, $bundle) {
  $record = array(
    'field_name' => $field_name,
    'field_path' => $field_path,
    'entity_type' => $entity_type,
    'bundle' => $bundle,
  );
  drupal_write_record('cap_api_fields_map', $record);
}

/**
 * Get schema hash.
 *
 * @param array $schema
 *   Profile schema.
 *
 * @return string
 *   Profile schema hash.
 */
function _stanford_cap_api_profiles_schema_hash($schema) {
  return md5(var_export($schema, TRUE));
}

/**
 * Helper to show some info about schema synchronization batch.
 */
function _stanford_cap_api_profiles_sync_schema_batch_finished() {
  $time = REQUEST_TIME - variable_get('stanford_cap_api_profiles_sync_schema_batch');
  variable_del('stanford_cap_api_profiles_sync_schema_batch');
  drupal_set_message(t('Fields successfully synchronized.'));
  drupal_set_message(t('This operation took %time seconds.', array('%time' => $time)));
  menu_rebuild();
}

/**
 * Helper to trigger schema synchronization in batch mode.
 */
function _stanford_cap_api_profiles_sync_schema_batch() {
  stanford_cap_api_profiles_synchronize_schema(TRUE);
}

/**
 * Helper to save profile image to file.
 *
 * @param string $field_name
 *   Profile field name.
 * @param array $field_data
 *   Field data.
 *
 * @return int
 *   New file ID or NULL in case of error.
 */
function _stanford_cap_api_profiles_save_image_file($field_name, $field_data) {
  $ext = drupal_substr($field_data['contentType'], 6);
  $request_url = $field_data['url'];
  parse_str(parse_url($request_url, PHP_URL_QUERY), $query);
  $profile_id = $query['facultyId'];

  $response = drupal_http_request($request_url);
  if (property_exists($response, 'error')) {
    $error_msg = 'Failed to fetch profile image of field "%field_name" for profile "%profile_id". Error code is "%code", error message is "%msg", request string was "%request".';
    $vars = array(
      '%code' => $response->code,
      '%msg' => $response->status_message,
      '%request' => $request_url,
      '%profile_id' => $profile_id,
      '%field_name' => $field_name,
    );
    watchdog('stanford_cap_api_profiles', $error_msg, $vars, WATCHDOG_WARNING);

    return NULL;
  }
  else {
    // @todo Add check is file exists and size is same, other way we will multiple DB file entries every sync.
    $file_dir = 'cap_profile_images';
    $path = 'public://'
      . $file_dir
      . '/profile_'
      . $profile_id . '_' . $field_data['type'] . '.' . $ext;
    $dir = drupal_dirname($path);
    if (!is_dir($dir) && !mkdir($dir)) {
      watchdog('stanford_cap_api_profiles', 'Failed to create directory %dir', array('%dir' => $dir), WATCHDOG_WARNING);

      return NULL;
    }
    $file = file_save_data($response->data, $path, FILE_EXISTS_REPLACE);

    return $file->fid;
  }
}

/**
 * Helper for batch to store correct sync time.
 */
function _stanford_cap_api_profiles_sync_group_save_wrapper($type, $name, $count, $sync_children = 0) {
  stanford_cap_api_profiles_sync_group_save($type, $name, $count, REQUEST_TIME, $sync_children);
}

/**
 * Indicates does this field should be imported or not based on field path.
 *
 * @param string $field_path
 *   Field path.
 *
 * @return bool
 *   Indicates if we should synchronize this field.
 */
function stanford_cap_api_profiles_synchronize_field($field_path) {
  $synchronize = FALSE;
  switch (variable_get('stanford_cap_api_import_profile_fields', CAP_FIELDS_IMPORT_ALL)) {
    case CAP_FIELDS_IMPORT_ALL:
      $synchronize = TRUE;
      break;

    case CAP_FIELDS_IMPORT_LIST:
      $field_list = variable_get('stanford_cap_api_profiles_sync_field_list', array());
      $synchronize = _stanford_cap_api_profiles_synchronize_field($field_path, $field_list);
      break;

    case CAP_FIELDS_IMPORT_LAYOUT:
      if (module_exists('stanford_cap_api_profiles_layout')) {
        $plain_layout = stanford_cap_api_profiles_layout_get_plain();
        $synchronize = _stanford_cap_api_profiles_synchronize_field($field_path, $plain_layout);
      }
      else {
        $synchronize = TRUE;
      }
      break;
  }

  return $synchronize;
}

/**
 * Indicates does this field should be imported or not based on field path.
 *
 * @param string $field_path
 *   Field path.
 * @param array $field_list
 *   Array of fields to be synced.
 *
 * @return bool
 */
function _stanford_cap_api_profiles_synchronize_field($field_path, $field_list){
  $synchronize = FALSE;
  if (in_array($field_path, $field_list)) {
    $synchronize = TRUE;
  }
  else {
    // Top level field.
    if (strpos($field_path, '.') === FALSE) {
      // SUNET ID field should be included no matter what.
      if ($field_path == 'uid') {
        $synchronize = TRUE;
      }
      else {
        // This field didn't listed directly, but maybe it's parent of other
        // field.
        foreach ($field_list as $layout_field_path) {
          if (in_array($field_path, explode('.', $layout_field_path))) {
            $synchronize = TRUE;
            break;
          }
        }
      }
    }
    else {
      $levels = count(explode('.', $field_path));
      foreach ($field_list as $layout_field_path) {
        $layout_field_path_part = implode('.', array_slice(explode('.', $layout_field_path), 0, $levels));
        if ($field_path == $layout_field_path_part) {
          $synchronize = TRUE;
          break;
        }
      }
    }
  }

  return $synchronize;
}

/**
 * Returns list of orgCode fields.
 */
function stanford_cap_api_profiles_get_orgcode_fields() {
  $orgcode_fields = array();
  $schema = stanford_cap_api_profiles_get_profile_schema();
  foreach ($schema['properties'] as $f_name => $f_schema) {
    _stanford_cap_api_profiles_get_orgcode_fields($f_name, $f_schema, $orgcode_fields);
  }

  return $orgcode_fields;
}

/**
 * Iterates over profile fields to find "orgCode" fields.
 */
function _stanford_cap_api_profiles_get_orgcode_fields($f_name, $f_schema, &$orgcode_fields, $parent_field = '') {
  $field_path = empty($parent_field) ? $f_name : $parent_field . '.' . $f_name;
  if ($f_name == 'orgCode') {
    $orgcode_fields[] = $field_path;
  }
  $subfields = array();
  if ($f_schema['type'] == 'array' && $f_schema['items']['type'] == 'object') {
    $subfields = $f_schema['items']['properties'];
  }
  elseif ($f_schema['type'] == 'object' && !empty($f_schema['properties'])) {
    $subfields = $f_schema['properties'];
  }
  foreach ($subfields as $subfield => $schema) {
    _stanford_cap_api_profiles_get_orgcode_fields($subfield, $schema, $orgcode_fields, $field_path);
  }
}

/**
 * Implements hook_library().
 */
function stanford_cap_api_profiles_library() {
  $libraries['stanford_cap_api_profiles_fields'] = array(
    'version' => '1.0-beta',
    'js' => array(
      drupal_get_path('module', 'stanford_cap_api_profiles') . '/stanford_cap_api_profiles.js' => array(),
    ),
    'css' => array(
      drupal_get_path('module', 'stanford_cap_api_profiles') . '/stanford_cap_api_profiles.css' => array(),
    ),
  );

  return $libraries;
}

/**
 * Figure out organization term id from title field.
 *
 * @param object $nw
 *   Node wrapper object.
 *
 * @param string $title_type
 *   From which title field organization should be taken.
 *   Available options are 'short' and 'long'.
 *
 * @return int
 *   Organization taxonomy term ID.
 */
function _stanford_cap_api_profiles_get_orantization_tid($nw, $title_type = 'short') {
  $tid = NULL;
  switch ($title_type) {
    case 'short':
      $node_field = 'cap_shorttitle';
      $field_path = 'shortTitle.organization.orgCode';
      break;

    case 'long':
      $node_field = 'cap_longtitle';
      $field_path = 'longTitle.organization.orgCode';
      break;

    default:
      return;
  }
  $field_info = _stanford_cap_api_profiles_get_field_info_by_path($field_path);
  $title = $nw->{$node_field}->value();
  if ($title) {
    $org = $nw->{$node_field}->{$field_info['bundle']}->value();
    if ($org) {
      $term = $nw->{$node_field}->{$field_info['bundle']}->{$field_info['field_name']}->value();
      if ($term) {
        $tid = $nw->{$node_field}->{$field_info['bundle']}->{$field_info['field_name']}->tid->value();
      }
    }
  }

  return $tid;
}

/**
 * Implements hook_views_default_views_alter().
 *
 * Disables 'Manage profiles' view if profiles schema not synchronized yet.
 */
function stanford_cap_api_profiles_views_default_views_alter(&$views) {
  if (!variable_get('stanford_cap_api_profiles_schema_synchronized', FALSE) && isset($views['cap_api_manage_profiles'])) {
    $views['cap_api_manage_profiles']->disabled = TRUE;
  }
}
